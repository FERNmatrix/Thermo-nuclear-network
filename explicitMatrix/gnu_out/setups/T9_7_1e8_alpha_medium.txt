branch guidry_debugRG, Oct 11, 2022

#define ISOTOPES 16                   // Max isotopes in network (e.g. 16 for alpha network)
#define SIZE 48                       // Max number of reactions (e.g. 48 for alpha network)

#define plotSteps 100               // Number of plot output steps
#define LABELSIZE 35                  // Max size of reaction string a+b>c in characters
#define PF 24                         // Number entries partition function table for isotopes
#define THIRD 0.333333333333333
#define TWOTHIRD 0.66666666666667
#define ECON 9.5768e17                // Convert MeV/nucleon/s to erg/g/s
#define LOG10 0.434294481903251       // Conversion natural log to log10
#define MEV 931.494                   // Conversion of amu to MeV
#define GZ 1.0e-24                    // Constant to ensure 1/max(num, GZ) never divides by 0

#define unitd static_cast<double>(1.0)  // Constant double equal to 1
#define zerod static_cast<double>(0.0)  // Constant double equal to 0

// File pointers for diagnostics output. Corresponding filenames declared 
// at top of main.

FILE* pFileD;
FILE* pfnet;

// Filename for network + partition function input.  The file output/CUDAnet.inp
// output by the Java code through the stream toCUDAnet has the expected format 
// for this file. Standard filenames for test cases are listed in table above.

char networkFile[] = "data/network_alpha.inp";

// Filename for input rates library data. The file rateLibrary.data output by 
// the Java code through the stream toRateData has the expected format for this 
// file.  Standard filenames for test cases are listed in table above.

char rateLibraryFile[] = "data/rateLibrary_alpha.data";

// Whether to use constant T and rho (hydroProfile false), in which case a
// constant T9 = T9_start and rho = rho_start are used, or to read
// in a hydrodynamical profile of T and rho versus time (hydroProfile true),
// in which case the file to be read in is specified by the character variable 
// hydroFile[].

bool hydroProfile = false; 

// Filename for input file containing a hydro profile in temperature
// and density that is used if hydroProfile = true. Sample hydro profile 
// files included in the data subdirectory are
//
//    data/torch47Profile.data         // Very hot Type Ia supernova zone
//    data/nova125DProfile.inp         // Representative zone in nova explosion
//    data/tidalSNProfile_100.inp      // Zone in tidal supernova explosion
//
// Use SplineInterpolator to interpolate in table read in. If hydroProfile and 
// plotHydroProfile are true, the hydro profile used for the temperature and 
// density in the calculation is also output to the file gnu_out/hydroProfileInput.data
// in format suitable for gnuplot.

char hydroFile[] = "data/nova125DProfile_400.inp";

// Control output of hydro profile (if one is used) to plot file.

static const bool plotHydroProfile = true;

const static int maxHydroEntries = 403; // Max entries hydro profile

// Control printout of flux data (true to print, false to suppress).
// Lots of data, so most useful for small networks.
 
static const bool plotFluxes = false;

// Plot output controls and file pointers

static const int maxPlotIsotopes = min(ISOTOPES, 365);   // # species to plot
int plotXlist[maxPlotIsotopes];           // Array of species plot indices

// Pointers to data output files

FILE* plotfile1;
FILE* plotfile2;
FILE* plotfile3;
FILE* plotfile4;

// Control flags for diagnostic output to files. Note that setting showDetails
// or showDetails2 true may generate large output files (MB to GB for large networks).

bool showAddRemove = false;  // Show addition/removal of RG from equilibrium
bool showDetails = false;    // Controls diagnostics to pFileD -> gnu_out/diagnostics.data
bool showDetails2 = false;   // Controls diagnostics to pfnet -> gnu_out/network.data

// Control which explicit algebraic approximations are used. Eventually
// this should be set from a data file. To use asymptotic set doASY true
// (which toggles doQSS to false). To use quasi-steady-state (QSS),set 
// doASY false (which toggles doQSS to true). doPE can be true or false 
// with either Asymptotic or QSS. The boolean showPE allows display of the number
// of reaction groups (RG) that would be in equilibrium if PE approximation were
// being implemented. It is true only if Asy or QSS, but PE not being
// implemented.

bool doASY = true;           // Whether to use asymptotic approximation
bool doQSS = !doASY;         // Whether to use QSS approximation 
bool doPE = true;            // Implement partial equilibrium also
bool showPE = !doPE;         // Show RG that would be in equil if doPE=false

string intMethod = "";       // String holding integration method
string ts;                   // Utility string

// Temperature and density variables. Temperature and density can be
// either constant, or read from a hydro profile as a function of time.

double T9;                   // Current temperature in units of 10^9 K
double rho;                  // Current density in units of g/cm^3

// Energy variables (from Q values)

double ERelease;              // Total energy released
double dERelease;             // Energy released per unit time
double netdERelease;          // Energy released in timestep

// Partition function controls. If dopf = true, reaction rates are
// corrected by temperature-dependent partition functions.  However
// partition function factors differ from 1 only at high temperature
// so we only implement partition function corrections if T9 > pfCut9,
// where pfCut9 is a cutoff temperature in units of T9. Typically in
// realistic calculation we would choose dopf = true and pfCut9 = 1.0.

bool dopf = true;
double pfCut9 = 1.0;

// Temperatures in units of 10^9 K for partition function table (see pf[]
// in the class Species). 

double Tpf[PF] = {0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 
1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};
    
// Array holding the value of the partition function for each isotope at
// the current temperature if dopf = true and T9 > pfCut9.
    
double currentPF[ISOTOPES];

// Array to hold whether given species satisfies asymptotic condition
// True (1) if asyptotic; else false (0).

bool isAsy[ISOTOPES];         // True if isotope is asymptotic
double asycheck;              // Species asymptotic if asycheck > 1.0
double asyFrac = 0.0;         // Fraction isotopes that are asymptotic

// Whether isotope part of any RG in partial equilibrium this timestep

bool isotopeInEquil[ISOTOPES]; 

// isotopeInEquil[] from last timestep

bool isotopeInEquilLast[ISOTOPES]; 

// Set the temperature in units of 10^9 K and density in units of g/cm^3. In a
// realistic calculation the temperature and density will be passed from the hydro 
// code in an operator-split coupling of this network to hydro. Here we hardwire
// constant values for testing purposes, or read in a temperature and density
// hydro profile if hydroProfile is true.

double T9_start = 7;           // Initial temperature in units of 10^9 K
double rho_start = 1e8;        // Initial density in g/cm^3

// Integration time data. The variables start_time and stop_time 
// define the range of integration (all time units in seconds),
// and dt_start sets the initial integration timestep. In an operator-split 
// coupling  start_time will be 0, stop_time will correspond to the length
// of the hydro timestep and dt_init will likely be something like the 
// last timestep of the previous network integration (for the preceding 
// hydro timestep). Here we hardwire them for testing purposes.
// The variable startplot_time allows the plotting interval output
// in gnu_out/gnufile.data to be a subset of the full integration interval. 
// Generally, startplot_time > start_time.  By default the stop time for
// plotting is the same as the stop time for integration, stop_time.

double start_time = 1e-20;             // Start time for integration
double logStart = log10(start_time);   // Base 10 log start time
double startplot_time = 1e-18;          // Start time for plot output
double stop_time = 1e-2;                // Stop time for integration
double logStop = log10(stop_time);     // Base-10 log stop time5
double dt_start = 0.01*start_time;     // Initial value of integration dt
double dt_saved;                       // Full timestep used for this int step
double t_saved;                        // Start time this timestep (end t for last step)
double dt_half;                        // Half of full timestep
double dt_change;                      // Change in proposed dt from last timestep
double t_end;                          // End time for this timestep
double dt_new;                         // Variable used in computeNextTimeStep()
double dtmin;                          // Variable used in computeNextTimeStep()
double dt_desired;                     // dt desired if not prevented by plot timestep
double dt_ceiling = 0.1;               // Max timestep is dt_ceiling*t, for accuracy

double dt_FE = dt_start;               // Max stable forward Euler timestep
double dt_EA = dt_start;               // Max asymptotic timestep

int dtMode;                            // Dual dt stage (0=full, 1=1st half, 2=2nd half)

double massTol_asy = 1e-2;             // Tolerance param if no reactions equilibrated
double massTol_asyPE = 6e-3;           // Tolerance param if some reactions equilibrated
double massTol = massTol_asy;          // Timestep tolerance parameter for integration
double downbumper = 0.7;               // Asy dt decrease factor
double sf = 1e25;                      // dt_FE = sf/fastest rate
int maxit = 100;                       // Max asy dt iterations allowed for a step
int iterations;                        // # iterations in step to conserve particles 
int totalIterations;                   // Total number of iterations, all steps til now
int mostIterationsPerStep = 0;         // Most iterations in a timestep
int maxIterationStep;                  // Step where mostIterationsPerStep occurred
double maxIterationTime;               // Time where mostIterationsPerStep occurred
double Error_Observed;                 // Observed integration error
double Error_Desired;                  // Desired max local integration error
double E_R;                            // Ratio actual to desired error
double EpsA = 6e-3;                    // Absolute error tolerance
double EpsR = 2.0e-4;                  // Relative error tolerance (not presently used)

// equilTime is time to begin imposing partial equilibrium if doPE=true. Hardwired but 
// eventually should be determined by the program.  In the Java version this was sometimes
// needed because starting PE test too early could lead to bad results.  This is 
// probably an error in the Java version, since if operating properly nothing should
// be changed at a timestep if nothing satisfies PE condition.  Thus, we should not need
// this in a final version for stability, but it might still be useful since early in
// a calculation typically nothing satisfies PE, so checking for it is a waste of time.
// On the other hand, the check costs little computing time so to make the code more
// universal it may be best to check for equilibration from the beginning of the 
// calculation. 

double equilTime = start_time;    // Time to begin checking for PE

double equiTol = 0.015;           // Tolerance for checking whether Ys in RG in equil
double deviousMax = 0.3;          // Max allowed deviation from equil k ratio in timestep

--------------------------------------

95 it=0 t=1.64e-03 dt=1.64e-04 dt'=1.49e-04 int=756 asy=0.50 eq=0.53 sX=1.000 Xfac=0.999 dE=3.41e+18 E=-2.36e+17 E_R=4.50e-01 c1=0 c2=1 fast=13 Q=-4.73 dev=2.54e-03 lT=9.845 lrho=8.00
96 it=0 t=2.40e-03 dt=2.40e-04 dt'=2.18e-04 int=760 asy=0.50 eq=0.53 sX=1.000 Xfac=0.999 dE=9.11e+18 E=-2.31e+17 E_R=5.43e-01 c1=0 c2=1 fast=13 Q=-4.73 dev=1.99e-03 lT=9.845 lrho=8.00
97 it=0 t=3.51e-03 dt=3.51e-04 dt'=3.19e-04 int=764 asy=0.50 eq=0.53 sX=1.000 Xfac=0.999 dE=1.33e+19 E=-2.18e+17 E_R=6.17e-01 c1=0 c2=1 fast=13 Q=-4.73 dev=1.49e-03 lT=9.845 lrho=8.00
98 it=0 t=5.14e-03 dt=5.14e-04 dt'=4.68e-04 int=768 asy=0.50 eq=0.53 sX=1.000 Xfac=1.000 dE=1.65e+19 E=-1.92e+17 E_R=6.72e-01 c1=0 c2=1 fast=13 Q=-4.73 dev=1.30e-03 lT=9.845 lrho=8.00
99 it=0 t=7.53e-03 dt=7.53e-04 dt'=6.85e-04 int=772 asy=0.50 eq=0.53 sX=1.000 Xfac=1.000 dE=1.94e+19 E=-1.48e+17 E_R=7.10e-01 c1=0 c2=1 fast=13 Q=-4.73 dev=9.81e-04 lT=9.845 lrho=8.00
100 it=0 t=1.00e-02 dt=1.00e-03 dt'=9.11e-04 int=775 asy=0.50 eq=0.53 sX=1.000 Xfac=1.000 dE=2.16e+19 E=-9.64e+16 E_R=7.29e-01 c1=0 c2=1 fast=13 Q=-4.73 dev=8.63e-04 lT=9.845 lrho=8.00

Integration using ASY+PE method (Partition function corrections applied for T9=1.00 and above)
T9=7.000e+00 (constant) rho=1.000e+08 (constant) massTol_asy=1.00e-02 massTol_PE=6.00e-03
sf=1.00e+25 equiTol=1.50e-02 equilTime=1.00e-20
maxit=100 downbumper= 0.700 EpsA=6.00e-03 EpsR=2.00e-04 deviousMax=0.300
Network: data/network_alpha.inp  Rates: data/rateLibrary_alpha.data
Isotopes=16 Reactions=48 ReactionGroups=19 SingletRG=0
Integration steps=775 totalIterations=719 IntegrationSteps_plotted=719
Max dt iterations = 20 at step 573 (t=9.856e-06)
Timer: 3.5435e-02 sec used

FINAL ABUNDANCES Y AND MASS FRACTIONS X

0 4He Y=1.1086e-01 X=4.4342e-01
1 12C Y=5.7209e-06 X=6.8651e-05
2 16O Y=1.0443e-05 X=1.6708e-04
3 20Ne Y=3.5609e-07 X=7.1219e-06
4 24Mg Y=2.2408e-05 X=5.3780e-04
5 28Si Y=2.7418e-03 X=7.6769e-02
6 32S Y=2.2967e-03 X=7.3496e-02
7 36Ar Y=1.3418e-03 X=4.8305e-02
8 40Ca Y=1.1900e-03 X=4.7601e-02
9 44Ti Y=1.1553e-04 X=5.0835e-03
10 48Cr Y=4.3007e-04 X=2.0643e-02
11 52Fe Y=1.6839e-03 X=8.7565e-02
12 56Ni Y=3.4997e-03 X=1.9598e-01
13 60Zn Y=5.8394e-06 X=3.5037e-04
14 64Ge Y=5.0116e-09 X=3.2074e-07
15 68Se Y=9.8177e-12 X=6.6760e-10
