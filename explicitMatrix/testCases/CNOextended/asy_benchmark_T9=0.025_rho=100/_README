CNOextended Benchmark calculation T9=0.025 rho=100

 Nov 12, 2022  branch: guidry_debugRG  hash: 4a58da3
 -----------------------------------------------------
 
 #define ISOTOPES 16                   // Max isotopes in network (e.g. 16 for alpha network)
 #define SIZE 134                      // Max number of reactions (e.g. 48 for alpha network)
 
 #define plotSteps 200               // Number of plot output steps
 #define LABELSIZE 35                  // Max size of reaction string a+b>c in characters
 #define PF 24                         // Number entries partition function table for isotopes
 #define THIRD 0.333333333333333
 #define TWOTHIRD 0.66666666666667
 #define ECON 9.5768e17                // Convert MeV/nucleon/s to erg/g/s
 #define LOG10 0.434294481903251       // Conversion natural log to log10
 #define MEV 931.494                   // Conversion of amu to MeV
 #define GZ 1.0e-24                    // Constant to ensure 1/max(num, GZ) never divides by 0
 
 #define unitd static_cast<double>(1.0)  // Constant double equal to 1
 #define zerod static_cast<double>(0.0)  // Constant double equal to 0
 
 // File pointers for diagnostics output. Corresponding filenames declared 
 // at top of main.
 
 FILE* pFileD;
 FILE* pfnet;
 
 // Filename for network + partition function input.  The file output/CUDAnet.inp
 // output by the Java code through the stream toCUDAnet has the expected format 
 // for this file. Standard filenames for test cases are listed in table above.
 
 char networkFile[] = "data/network_cnoAll.inp";
 
 // Filename for input rates library data. The file rateLibrary.data output by 
 // the Java code through the stream toRateData has the expected format for this 
 // file.  Standard filenames for test cases are listed in table above.
 
 char rateLibraryFile[] = "data/rateLibrary_cnoAll.data";
 
 // Whether to use constant T and rho (hydroProfile false), in which case a
 // constant T9 = T9_start and rho = rho_start are used, or to read
 // in a hydrodynamical profile of T and rho versus time (hydroProfile true),
 // in which case the file to be read in is specified by the character variable 
 // hydroFile[].
 
 bool hydroProfile = false; 
 
 // Filename for input file containing a hydro profile in temperature
 // and density that is used if hydroProfile = true. Sample hydro profile 
 // files included in the data subdirectory are
 //
 //    data/torch47Profile.data         // Very hot Type Ia supernova zone
 //    data/nova125DProfile.inp         // Representative zone in nova explosion
 //    data/tidalSNProfile_100.inp      // Zone in tidal supernova explosion
 //
 // Use SplineInterpolator to interpolate in table read in. If hydroProfile and 
 // plotHydroProfile are true, the hydro profile used for the temperature and 
 // density in the calculation is also output to the file gnu_out/hydroProfileInput.data
 // in format suitable for gnuplot.
 
 char hydroFile[] = "data/nova125DProfile_400.inp";
 
 // Control output of hydro profile (if one is used) to plot file.
 
 static const bool plotHydroProfile = true;
 
 const static int maxHydroEntries = 403; // Max entries hydro profile
 
 // Control printout of flux data (true to print, false to suppress).
 // Lots of data, so most useful for small networks.
 
 static const bool plotFluxes = false;
 
 // Plot output controls and file pointers
 
 static const int maxPlotIsotopes = min(ISOTOPES, 365);   // # species to plot
 int plotXlist[maxPlotIsotopes];           // Array of species plot indices
 
 // Pointers to data output files
 
 FILE* plotfile1;
 FILE* plotfile2;
 FILE* plotfile3;
 FILE* plotfile4;
 FILE* plotfile5;
 
 // Control flags for diagnostic output to files. Note that setting showDetails
 // or showDetails2 true may generate large output files (MB to GB for large networks).
 
 bool showAddRemove = true;   // Show addition/removal of RG from equilibrium
 bool showDetails = false;    // Controls diagnostics to pFileD -> gnu_out/diagnostics.data
 bool showDetails2 = false;   // Controls diagnostics to pfnet -> gnu_out/network.data
 
 // Control which explicit algebraic approximations are used. Eventually
 // this should be set from a data file. To use asymptotic set doASY true
 // (which toggles doQSS to false). To use quasi-steady-state (QSS),set 
 // doASY false (which toggles doQSS to true). doPE can be true or false 
 // with either Asymptotic or QSS. The boolean showPE allows display of the number
 // of reaction groups (RG) that would be in equilibrium if PE approximation were
 // being implemented. It is true only if Asy or QSS, but PE not being
 // implemented.
 
 bool doASY = true;            // Whether to use asymptotic approximation
 bool doQSS = !doASY;          // Whether to use QSS approximation 
 bool doPE = false;             // Implement partial equilibrium also
 bool showPE = !doPE;          // Show RG that would be in equil if doPE=false
 
 string intMethod = "";        // String holding integration method
 string ts;                    // Utility string
 
 // Temperature and density variables. Temperature and density can be
 // either constant, or read from a hydro profile as a function of time.
 
 double T9;                    // Current temperature in units of 10^9 K
 double rho;                   // Current density in units of g/cm^3
 
 // EfromMasses = false if energy plotted from Q values; EfromMasses = true if energy 
 // is plotted from masses by weighing the network before and after timestep.
 // Generally should be set to EfromMasses = true, since energy from Q values and
 // mass differences are essentially the same for no PE approximation, but
 // for PE approximation the fluxes set to zero are not quite zero in reality
 // so fluxes computed from Q values are increasingly in error as more and
 // more reaction groups come into equilibrium.  Conversely, energies 
 // computed by weighing the network (mass differences weighted by abundances)
 // are approximately in agreement with exact calculations at the same level
 // as the agreement of the abundances. For now we will compute the energies 
 // both ways but by setting EfromMasses = true we will ensure that the more
 // correct energies (E and dE/dt) computed from mass differences are output to 
 // the plotting streams.
 
 bool EfromMasses = true;    // Set to true except for testing purposes       
 
 // Energy variables (from Q values)
 
 double ERelease;              // Total energy released
 double dERelease;             // Energy released per unit time
 double netdERelease;          // Energy released in timestep
 
 // Energy variables (from mass differences)
 
 double networkMass;           // Total mass in network at end of timestep
 double lastNetworkMass;       // Total network mass at beginning of timestep
 double netdEReleaseA;         // Net energy release in timestep dE from mass diffs
 double dEReleaseA;            // Differential E release dE/dt over timestep from masses
 double EReleaseA;             // Total E released up to this time from masses
 
 // Partition function controls. If dopf = true, reaction rates are
 // corrected by temperature-dependent partition functions.  However
 // partition function factors differ from 1 only at high temperature
 // so we only implement partition function corrections if T9 > pfCut9,
 // where pfCut9 is a cutoff temperature in units of T9. Typically in
 // realistic calculation we would choose dopf = true and pfCut9 = 1.0.
 
 bool dopf = true;
 double pfCut9 = 1.0;
 
 // Temperatures in units of 10^9 K for partition function table (see pf[]
 // in the class Species). 
 
 double Tpf[PF] = {0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 
     1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0};
     
     // Array holding the value of the partition function for each isotope at
     // the current temperature if dopf = true and T9 > pfCut9.
     
     double currentPF[ISOTOPES];
     
     // Array to hold whether given species satisfies asymptotic condition
     // True (1) if asyptotic; else false (0).
     
     bool isAsy[ISOTOPES];         // True if isotope is asymptotic
     double asycheck;              // Species asymptotic if asycheck > 1.0
     double asyFrac = 0.0;         // Fraction isotopes that are asymptotic
     
     // Whether isotope part of any RG in partial equilibrium this timestep
     
     bool isotopeInEquil[ISOTOPES]; 
     
     // isotopeInEquil[] from last timestep
     
     bool isotopeInEquilLast[ISOTOPES]; 
     
     // Set the temperature in units of 10^9 K and density in units of g/cm^3. In a
     // realistic calculation the temperature and density will be passed from the hydro 
     // code in an operator-split coupling of this network to hydro. Here we hardwire
     // constant values for testing purposes, or read in a temperature and density
     // hydro profile if hydroProfile is true.
     
     double T9_start = 0.025;           // Initial temperature in units of 10^9 K
     double rho_start = 100;        // Initial density in g/cm^3
     
     // Integration time data. The variables start_time and stop_time 
     // define the range of integration (all time units in seconds),
     // and dt_start sets the initial integration timestep. In an operator-split 
     // coupling  start_time will be 0, stop_time will correspond to the length
     // of the hydro timestep and dt_init will likely be something like the 
     // last timestep of the previous network integration (for the preceding 
     // hydro timestep). Here we hardwire them for testing purposes.
     // The variable startplot_time allows the plotting interval output
     // in gnu_out/gnufile.data to be a subset of the full15 integration interval. 
     // Generally, startplot_time > start_time.  By default the stop time for
     // plotting is the same as the stop time for integration, stop_time.
     
     double start_time = 1e-20;             // Start time for integration
     double logStart = log10(start_time);   // Base 10 log start time
     double startplot_time = 1e-4;         // Start time for plot output
     double stop_time = 0.8e17;               // Stop time for integration
     double logStop = log10(stop_time);     // Base-10 log stop time5
     double dt_start = 0.01*start_time;     // Initial value of integration dt
     double dt_saved;                       // Full timestep used for this int step
     double t_saved;                        // Start time this timestep (end t for last step)
     double dt_half;                        // Half of full timestep
     double dt_change;                      // Change in proposed dt from last timestep
     double t_end;                          // End time for this timestep
     double dt_new;                         // Variable used in computeNextTimeStep()
     double dtmin;                          // Variable used in computeNextTimeStep()
     double dt_desired;                     // dt desired if not prevented by plot timestep
     double dt_ceiling = 0.1;               // Max timestep is dt_ceiling*t, for accuracy
     
     double dt_FE = dt_start;               // Max stable forward Euler timestep
     double dt_EA = dt_start;               // Max asymptotic timestep
     
     int dtMode;                            // Dual dt stage (0=full, 1=1st half, 2=2nd half)
     
     double massTol_asy = 1e-12;             // Tolerance param if no reactions equilibrated
     double massTol_asyPE = 6e-6;//4e-3;           // Tolerance param if some reactions equilibrated
     double massTol = massTol_asy;          // Timestep tolerance parameter for integration
     double downbumper = 0.7;               // Asy dt decrease factor
     double sf = 1e25;                      // dt_FE = sf/fastest rate
     int maxit = 100;                       // Max asy dt iterations allowed for a step
     int iterations;                        // # iterations in step to conserve particles 
     int totalIterations;                   // Total number of iterations, all steps til now
     int mostIterationsPerStep = 0;         // Most iterations in a timestep
     int maxIterationStep;                  // Step where mostIterationsPerStep occurred
     double maxIterationTime;               // Time where mostIterationsPerStep occurred
     double Error_Observed;                 // Observed integration error
     double Error_Desired;                  // Desired max local integration error
     double E_R;                            // Ratio actual to desired error
     double EpsA = 1e-12;           // Absolute error tolerance
     double EpsR = 2.0e-4;                  // Relative error tolerance (not presently used)
     
     // equilTime is time to begin imposing partial equilibrium if doPE=true. Hardwired but 
     // eventually should be determined by the program.  In the Java version this was sometimes
     // needed because starting PE test too early could lead to bad results.  This is 
     // probably an error in the Java version, since if operating properly nothing should
     // be changed at a timestep if nothing satisfies PE condition.  Thus, we should not need
     // this in a final version for stability, but it might still be useful since early in
     // a calculation typically nothing satisfies PE, so checking for it is a waste of time.
     // On the other hand, the check costs little computing time so to make the code more
     // universal it may be best to check for equilibration from the beginning of the 
     // calculation. 
     
     double equilTime = start_time;    // Time to begin checking for PE
     double equiTol = 0.001;//0.015;           // Tolerance for checking whether Ys in RG in equil
     double deviousMax = 0.01;//0.5;          // Max allowed deviation from equil k ratio in timestep
     bool useDevious = false;          // Use thisDevious (true) of equil pops (false) to set equil
     bool useEquilY = true;            // Use equilibrium values of Y to impose PE
